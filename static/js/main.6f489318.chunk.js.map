{"version":3,"sources":["Components/NavHeader.js","Components/Node.js","algorithms/dijkstra.js","algorithms/astar.js","algorithms/bfs_bidirectional.js","algorithms/maze_generation.js","Components/Grid.js","algorithms/dfs.js","algorithms/bfs.js","App.js","index.js"],"names":["NavHeader","props","useState","algorithm","setAlgorithm","reset","simulateAlgorithm","generateMaze","placeWeights","Navbar","bg","variant","expand","className","Container","Nav","DropdownButton","id","title","Dropdown","Item","onClick","Button","Node","row","col","isStart","isEnd","isWall","isVisited","handleMouseDown","handleMouseEnter","handleMouseUp","isWeight","isPath","addedClassName","onMouseDown","onMouseEnter","onMouseUp","sortPQ","queue","totalCost","sort","nodeA","nodeB","get","recreateShortestPath","prevNodes","endNode","pathToNode","target","has","unshift","hScore","node","Math","sqrt","pow","fScore","bfs_step","grid","visited","parent","allNodesExplored","dI","dJ","root","shift","push","k","length","neighbor","add","set","isIntersecting","s_visited","e_visited","intersectionNode","sNode","maze_generation","divide","choose_orientation","y","x","height","width","orientation","new_wall","new_hole","new_height","new_width","y_pair","x_pair","new_height_pair","new_width_pair","floor","getRandomIntInclusive","i","random","min","max","ceil","starting_location","GRID_ROWS","ending_location","createInitialGrid","rows","cols","currRow","j","weight","Grid","setGrid","mouseDown","setMouseDown","startNode","weightNode","placeNode","setPlaceNode","placeNewNode","placeNodeState","copyGrid","useEffect","paths","algoName","Set","stack","pop","pathToNeighbor","shortestPath","fullPath","dfs","bfs","Map","m","n","v","Infinity","alt","dijkstra","gScore","tempGScore","astar","s_queue","e_queue","s_parent","e_parent","startPath","endPath","reverse","bfs_bidirectional","runAlgorithm","setTimeout","ANIMATION_SPEED","renderShortestPath","wallQueue","animateMazeGeneration","onMouseLeave","map","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6f489318.chunk.js","sourcesContent":["import React, { useState } from \"react\";\r\nimport \"./css/NavHeader.scss\";\r\nimport { Button, DropdownButton, Dropdown, Navbar, Container, Nav } from 'react-bootstrap';\r\n\r\nfunction NavHeader(props) {\r\n    const [algorithm, setAlgorithm] = useState(\"Choose Algorithm\");\r\n    const {reset, simulateAlgorithm, generateMaze, placeWeights} = props\r\n\r\n    return (\r\n        <Navbar bg=\"dark \" variant=\"dark\" expand=\"lg\">\r\n            <h2 className=\"header-nav\">Pathfinding Visualizer</h2>\r\n            <Container className=\"nav-buttons\">\r\n                    <Nav className=\"me-auto\">\r\n                        <DropdownButton className=\"nav-item\" id=\"dropdown-basic-button\" title={algorithm} >\r\n                            <Dropdown.Item onClick={()=>setAlgorithm(\"DFS\")}>DFS</Dropdown.Item>\r\n                            <Dropdown.Item onClick={()=>setAlgorithm(\"BFS\")}>BFS</Dropdown.Item>\r\n                            <Dropdown.Item onClick={()=>setAlgorithm(\"Bidirectional BFS\")}>Bidirectional BFS</Dropdown.Item>\r\n                            <Dropdown.Item onClick={()=>setAlgorithm(\"Dijkstra\")}>Dijkstra</Dropdown.Item>\r\n                            <Dropdown.Item onClick={()=>setAlgorithm(\"A*\")}>A*</Dropdown.Item>\r\n                        </DropdownButton>\r\n                        <Button className=\"nav-item\" variant=\"warning\" onClick={()=>generateMaze()}>Generate Maze</Button>\r\n                        <Button className=\"nav-item\" variant=\"success\" onClick={()=>simulateAlgorithm(algorithm)}>Visualize Algorithm</Button>\r\n                        <Button className=\"nav-item\" variant=\"secondary\" onClick={()=>placeWeights()}>Add Weights</Button>\r\n                        <Button className=\"nav-item\" variant=\"danger\" onClick={()=>reset()}>Clear Grid</Button>\r\n                    </Nav>\r\n            </Container>\r\n        </Navbar>\r\n    );\r\n}\r\n\r\nexport default NavHeader;","import React from \"react\";\r\nimport \"./css/Node.scss\";\r\n\r\nfunction Node(props) {\r\n    const {row, col, isStart, isEnd, isWall, isVisited,  handleMouseDown, \r\n        handleMouseEnter, handleMouseUp, isWeight, isPath} = props;\r\n    let addedClassName = isStart ? \"node-start\" : isEnd ? \"node-end\" : \r\n                            isWall ? \"node-wall\" : isPath ? \"node-path\" : \r\n                            isVisited ? \"node-visited\" :  isWeight  ? \"node-weight\" : \"\";\r\n    return (\r\n        <div \r\n            id={`${row}, ${col}`}\r\n            className={`node ${addedClassName}`}\r\n            onMouseDown={() => handleMouseDown(row, col)}\r\n            onMouseEnter={() => handleMouseEnter(row, col)}\r\n            onMouseUp={() => handleMouseUp()}\r\n        >\r\n        </div>\r\n    )\r\n  \r\n}\r\n\r\n\r\n\r\n\r\nexport default Node;","export function dijkstra(grid, startNode, endNode) {\r\n    let allNodesExplored = [];\r\n    let prevNodes = new Map(); \r\n    let totalCost = new Map();\r\n    let queue = []; // minHeap\r\n    const dI = [-1, 1, 0, 0] // 4 directions in array format\r\n    const dJ = [0, 0, -1, 1] // 4 directions in array format\r\n\r\n    for (let m = 0; m < grid.length; m++) {\r\n        for (let n = 0; n < grid[0].length; n++) {\r\n            let v = grid[m][n];\r\n            totalCost.set(v, Infinity);\r\n            prevNodes.set(v, null);\r\n            queue.push(v);\r\n        }\r\n    }\r\n    totalCost.set(startNode, 0); \r\n\r\n    while (queue.length > 0) {\r\n        sortPQ(queue, totalCost);\r\n        let root = queue.shift(); \r\n        allNodesExplored.push(root);\r\n        if (root.isWall)\r\n            continue;\r\n        if (root === endNode)\r\n            break;\r\n        for (let k = 0; k < 4; k++) {\r\n            if (root.row + dI[k] < 0 || root.row + dI[k] >= grid.length || \r\n                root.col + dJ[k] < 0 || root.col + dJ[k] >= grid[0].length)\r\n                continue;\r\n            let neighbor = grid[root.row + dI[k]][root.col + dJ[k]];\r\n            let alt = totalCost.get(root) + neighbor.weight;\r\n            if (alt < totalCost.get(neighbor)) {\r\n                totalCost.set(neighbor, alt);\r\n                prevNodes.set(neighbor, root);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        shortestPath: recreateShortestPath(prevNodes, endNode), \r\n        fullPath: allNodesExplored\r\n    };\r\n}\r\n\r\nfunction sortPQ(queue, totalCost) {\r\n    return queue.sort((nodeA, nodeB) => totalCost.get(nodeA) - totalCost.get(nodeB));\r\n}\r\n\r\nexport function recreateShortestPath(prevNodes, endNode) {\r\n    let pathToNode = [];\r\n    let target = endNode;\r\n    while (prevNodes.has(target)) {\r\n      pathToNode.unshift(target);\r\n      target = prevNodes.get(target);\r\n    }\r\n    return pathToNode;\r\n}","import {recreateShortestPath} from \"./dijkstra\";\r\n\r\nexport function astar(grid, startNode, endNode) {\r\n    let queue = [startNode];\r\n    let visited = new Set();\r\n    let prevNodes = new Map(); \r\n    let allNodesExplored = [];\r\n\r\n    let gScore = new Map();\r\n    let fScore = new Map();\r\n    const dI = [-1, 1, 0, 0] // 4 directions in array format\r\n    const dJ = [0, 0, -1, 1] // 4 directions in array format\r\n\r\n    for (let m = 0; m < grid.length; m++) {\r\n        for (let n = 0; n < grid[0].length; n++) {\r\n            let v = grid[m][n];\r\n            gScore.set(v, Infinity);\r\n            fScore.set(v, Infinity);\r\n            prevNodes.set(v, null);\r\n        }\r\n    }\r\n\r\n    gScore.set(startNode, 0);\r\n    fScore.set(startNode, hScore(startNode, endNode));\r\n\r\n    while (queue.length > 0) {\r\n        sortPQ(queue, fScore);\r\n        let root = queue.shift();\r\n        if (root.isWall || visited.has(root))\r\n            continue;\r\n        if (root === endNode)\r\n            break;\r\n        visited.add(root);\r\n        allNodesExplored.push(root);\r\n        for (let k = 0; k < 4; k++) {\r\n            if (root.row + dI[k] < 0 || root.row + dI[k] >= grid.length || \r\n                root.col + dJ[k] < 0 || root.col + dJ[k] >= grid[0].length)\r\n                continue;\r\n            let neighbor = grid[root.row + dI[k]][root.col + dJ[k]];\r\n            let tempGScore = gScore.get(root) + hScore(root, neighbor);\r\n            if (tempGScore < gScore.get(neighbor)) {\r\n                gScore.set(neighbor, tempGScore);\r\n                fScore.set(neighbor, gScore.get(neighbor) + hScore(neighbor, endNode));\r\n                prevNodes.set(neighbor, root);\r\n                queue.push(neighbor);\r\n            }\r\n        }      \r\n    }\r\n    return {\r\n        shortestPath: recreateShortestPath(prevNodes, endNode), \r\n        fullPath: allNodesExplored\r\n    };\r\n}\r\n\r\nfunction hScore(node, endNode) {\r\n    return Math.sqrt(Math.pow(node.row - endNode.row, 2) + Math.pow(node.col - endNode.col, 2))\r\n}\r\n\r\nfunction sortPQ(queue, fScore) {\r\n    queue.sort((nodeA, nodeB)=>{return fScore.get(nodeA) - fScore.get(nodeB)});\r\n}","import {recreateShortestPath} from \"./dijkstra\";\r\n\r\nexport function bfs_bidirectional(grid, startNode, endNode) {\r\n    const s_queue = [startNode];\r\n    const e_queue = [endNode];\r\n    const s_visited = new Set();\r\n    const e_visited = new Set();\r\n    const s_parent = new Map();\r\n    const e_parent = new Map();\r\n    const allNodesExplored = [];\r\n    let pathToNode = [];\r\n    const dI = [-1, 1, 0, 0] // 4 directions in array format\r\n    const dJ = [0, 0, -1, 1] // 4 directions in array format\r\n    let intersectionNode = { node: null };\r\n    s_visited.add(startNode);\r\n    e_visited.add(endNode);\r\n    s_parent.set(startNode, null);\r\n    e_parent.set(endNode, null);\r\n    \r\n    while (s_queue.length > 0 && e_queue.length > 0) {\r\n        bfs_step(grid, s_queue, s_visited, s_parent, allNodesExplored, dI, dJ);\r\n        bfs_step(grid, e_queue, e_visited, e_parent, allNodesExplored, dI, dJ);\r\n        isIntersecting(s_visited, e_visited, intersectionNode);\r\n        if (intersectionNode.node != null) {\r\n            let startPath = recreateShortestPath(s_parent, intersectionNode.node);\r\n            let endPath = recreateShortestPath(e_parent, intersectionNode.node);\r\n            pathToNode = [...startPath, ...endPath.reverse()];\r\n            break;\r\n        }\r\n    }\r\n    return {\r\n        shortestPath: pathToNode,\r\n        fullPath: allNodesExplored\r\n    };\r\n}\r\n\r\nfunction bfs_step(grid, queue, visited, parent, allNodesExplored, dI, dJ) {\r\n    let root = queue.shift();\r\n    allNodesExplored.push(root);\r\n    for (let k = 0; k < 4; k++) {\r\n        if (root.row + dI[k] < 0 || root.row + dI[k] >= grid.length || \r\n            root.col + dJ[k] < 0 || root.col + dJ[k] >= grid[0].length)\r\n            continue;\r\n        const neighbor = grid[root.row + dI[k]][root.col + dJ[k]];\r\n        if (!visited.has(neighbor) && !neighbor.isWall) {\r\n            visited.add(neighbor);\r\n            parent.set(neighbor, root);\r\n            queue.push(neighbor);\r\n        }\r\n    }\r\n}\r\n\r\nfunction isIntersecting(s_visited, e_visited, intersectionNode) {\r\n    for (let sNode of s_visited) {\r\n        for (let eNode of e_visited) {\r\n            if (sNode === eNode) {\r\n                intersectionNode.node = sNode;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","const HORIZONTAL = 0;\r\nconst VERTICAL = 1;\r\n\r\nexport function maze_generation(grid, queue) {\r\n    divide(grid, queue, 0, 0, grid.length, grid[0].length, choose_orientation(grid.length, grid[0].length));\r\n}\r\n\r\nfunction divide(grid, queue, y, x, height, width, orientation) {\r\n    if (height < 4 || width < 4)\r\n        return;\r\n    \r\n    let horizontal = (orientation === HORIZONTAL);\r\n    let new_wall;\r\n    let new_hole;\r\n    let new_height;\r\n    let new_width;\r\n    let y_pair; \r\n    let x_pair;\r\n    let new_height_pair;\r\n    let new_width_pair;\r\n\r\n    if (horizontal) {\r\n        new_wall = y + (2 * Math.floor(Math.floor(getRandomIntInclusive(2, height - 3)) / 2));\r\n        new_hole = x + (2 * Math.floor(Math.floor(getRandomIntInclusive(1, width - 2)) / 2 ) + 1);\r\n\r\n        for (let i = x; i < (x + width); i++) {\r\n            if (i !== new_hole && !grid[new_wall][i].isStart && !grid[new_wall][i].isEnd)\r\n                queue.push(grid[new_wall][i]);\r\n        }\r\n\r\n        new_height = new_wall - y + 1;\r\n        new_width = width;\r\n        y_pair = new_wall;\r\n        x_pair = x;\r\n        new_height_pair = y + height - new_wall;\r\n        new_width_pair = width;\r\n    }\r\n    else {\r\n        new_wall = x + (2 * Math.floor(Math.floor(getRandomIntInclusive(2, width - 3)) / 2));\r\n        new_hole = y + (2 * Math.floor(Math.floor(getRandomIntInclusive(1, height - 2)) / 2 ) + 1);\r\n\r\n        for (let i = y; i < (y + height); i++) {\r\n            if (i !== new_hole && !grid[i][new_wall].isStart && !grid[i][new_wall].isEnd)\r\n                queue.push(grid[i][new_wall]);\r\n        }\r\n\r\n        new_height = height;\r\n        new_width = new_wall - x + 1;\r\n        y_pair = y;\r\n        x_pair = new_wall;\r\n        new_height_pair = height;\r\n        new_width_pair = x + width - new_wall;\r\n    }\r\n    divide(grid, queue, y, x, new_height, new_width, choose_orientation(new_height, new_width));\r\n    divide(grid, queue, y_pair, x_pair, new_height_pair, new_width_pair, choose_orientation(new_height_pair, new_width_pair));\r\n}\r\n\r\nfunction choose_orientation(height, width) {\r\n    if (width < height) \r\n        return HORIZONTAL; \r\n    else if (height < width) \r\n        return VERTICAL;\r\n    return (Math.floor(Math.random() * 2) === 0) ? HORIZONTAL : VERTICAL;\r\n}\r\n\r\nfunction getRandomIntInclusive(min, max) {\r\n    min = Math.ceil(min);\r\n    max = Math.floor(max);\r\n    return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\r\n}\r\n","import React, { useEffect, useState } from \"react\";\r\nimport NavHeader from \"./NavHeader\";\r\nimport Node from \"./Node\";\r\nimport \"./css/Grid.scss\";\r\nimport {dfs} from '../algorithms/dfs';\r\nimport {bfs} from '../algorithms/bfs';\r\nimport {dijkstra} from \"../algorithms/dijkstra\";\r\nimport {astar} from \"../algorithms/astar\";\r\nimport {bfs_bidirectional} from \"../algorithms/bfs_bidirectional\";\r\nimport {maze_generation} from \"../algorithms/maze_generation\";\r\n\r\n\r\n// If the mouse is down & you enter another div => set that to isWall \r\n\r\n\r\nconst GRID_ROWS = 26, GRID_COLS = 61;\r\nconst ANIMATION_SPEED = 10;\r\nconst starting_location = [GRID_ROWS / 2, Math.floor(GRID_COLS / 3)];\r\nconst ending_location = [GRID_ROWS / 2, Math.floor(GRID_COLS / 3) * 2];\r\nconst DEFAULT_NODE_WEIGHT = 1;\r\nconst WEIGHTED_NODE_WEIGHT = 100000;\r\n\r\n\r\nfunction Grid() {\r\n    const [grid, setGrid] = useState([]); // Controls current state of the grid\r\n    const [mouseDown, setMouseDown] = useState(false); // Controls mouse clicks\r\n    const [placeNode, setPlaceNode] = useState({ // Controls which object should be placed when a mouse click happens\r\n      startNode: false,\r\n      endNode: false, \r\n      weightNode: false\r\n    });\r\n\r\n\r\n    useEffect(() => { \r\n      setGrid(createInitialGrid(GRID_ROWS, GRID_COLS));\r\n    }, []);\r\n    \r\n\r\n    function simulateAlgorithm(algorithm) {\r\n      let paths = runAlgorithm(algorithm, grid);\r\n      if (paths == null)\r\n        return;\r\n      const {shortestPath, fullPath} = paths;\r\n      for (let i = 0; i <= fullPath.length; i++) {\r\n        if (i === fullPath.length) {\r\n          setTimeout(() => {\r\n            renderShortestPath(shortestPath);\r\n          }, ANIMATION_SPEED * i);\r\n          return;\r\n        }\r\n        setTimeout(() => {\r\n          const node = fullPath[i];\r\n          let copyGrid = [...grid];\r\n          copyGrid[node.row][node.col].isVisited = true;\r\n          setGrid(copyGrid);\r\n        }, ANIMATION_SPEED * i);\r\n      }\r\n    }\r\n    \r\n    function renderShortestPath(shortestPath) {\r\n      for (let i = 0; i < shortestPath.length; i++) {\r\n        setTimeout(() => {\r\n          const node = shortestPath[i];\r\n          let copyGrid = [...grid];\r\n          copyGrid[node.row][node.col].isPath = true;\r\n          setGrid(copyGrid);\r\n        }, (ANIMATION_SPEED * 3) * i);\r\n      }\r\n    }\r\n\r\n    function reset() {\r\n      setGrid(createInitialGrid(GRID_ROWS, GRID_COLS));\r\n    }\r\n\r\n    function handleMouseDown(i, j) {\r\n      setMouseDown(true);\r\n      placeNewNode(i,j);\r\n    }\r\n\r\n    function handleMouseEnter(i,j) {\r\n      if (!mouseDown)\r\n        return;\r\n      placeNewNode(i,j);\r\n    }\r\n\r\n    function handleMouseUp() {\r\n      setMouseDown(false);\r\n    }\r\n\r\n    function placeWeights() {\r\n      let placeNodeState = {...placeNode};\r\n      placeNodeState.weightNode = !placeNodeState.weightNode;\r\n      setPlaceNode(placeNodeState);\r\n    }\r\n\r\n    function placeNewNode(i, j) {\r\n      let placeNodeState = { ...placeNode };\r\n      let copyGrid = [...grid];\r\n      if (copyGrid[i][j].isStart) { // if click start node -> delete and mark that need to place start node next\r\n        copyGrid[i][j].isStart = false;\r\n        placeNodeState.startNode = true;\r\n      }\r\n      else if (copyGrid[i][j].isEnd) { // if click end node -> delete and mark that need to place end node next\r\n        copyGrid[i][j].isEnd = false;\r\n        placeNodeState.endNode = true;\r\n      }\r\n      else if (placeNodeState.startNode) { // if need to place start node -> place it at i, j\r\n        copyGrid[i][j].isStart = true;\r\n        copyGrid[i][j].isWall = false;\r\n        starting_location[0] = i;\r\n        starting_location[1] = j;\r\n        placeNodeState.startNode = false;\r\n      }\r\n      else if (placeNodeState.endNode) { // if need to place end node -> place it at i, j\r\n        copyGrid[i][j].isEnd = true;\r\n        copyGrid[i][j].isWall = false;\r\n        ending_location[0] = i;\r\n        ending_location[1] = j;\r\n        placeNodeState.endNode = false;\r\n      }\r\n      else if (placeNodeState.weightNode) { // if need to place weight -> place it at i,j\r\n        copyGrid[i][j].isWeight = true;\r\n        copyGrid[i][j].weight = WEIGHTED_NODE_WEIGHT;\r\n      }\r\n      else if (copyGrid[i][j].isWall)\r\n        copyGrid[i][j].isWall = false;\r\n      else\r\n        copyGrid[i][j].isWall = true;\r\n      setGrid(copyGrid);\r\n      setPlaceNode(placeNodeState);\r\n    }\r\n\r\n    function generateMaze() {\r\n      let copyGrid = [...grid];\r\n      let wallQueue = [];\r\n      maze_generation(copyGrid, wallQueue);\r\n      animateMazeGeneration(wallQueue);\r\n    }\r\n\r\n    function animateMazeGeneration(wallQueue) {\r\n      for (let i = 0; i < wallQueue.length; i++) {\r\n        setTimeout(() => {\r\n          const node = wallQueue[i];\r\n          let copyGrid = [...grid];\r\n          copyGrid[node.row][node.col].isWall = true;\r\n          setGrid(copyGrid);\r\n        }, 10 * i);\r\n      }\r\n    }\r\n\r\n    return (\r\n      <div>\r\n        <NavHeader reset={reset} simulateAlgorithm={simulateAlgorithm} generateMaze={generateMaze} placeWeights={placeWeights}/>\r\n        <div className=\"grid\" onMouseLeave={handleMouseUp}>\r\n          {grid.map((row) => (\r\n          <div className=\"board__row\">\r\n              {row.map((node) => (\r\n                <Node\r\n                row={node.row} \r\n                col={node.col} \r\n                isStart = {node.isStart}\r\n                isEnd = {node.isEnd}\r\n                isWall = {node.isWall}\r\n                isVisited = {node.isVisited}\r\n                isWeight = {node.isWeight}\r\n                isPath = {node.isPath}\r\n                weight = {node.weight}\r\n                handleMouseDown={handleMouseDown}\r\n                handleMouseEnter= {handleMouseEnter}\r\n                handleMouseUp= {handleMouseUp}\r\n                />\r\n              ))}\r\n              <br />\r\n          </div>\r\n          ))}\r\n        </div>\r\n      </div>\r\n    );\r\n}\r\n\r\n\r\nfunction createInitialGrid(rows, cols) {\r\n  let grid = [];\r\n  for (let i = 0; i < rows; i++) {\r\n    let currRow = [];\r\n    for (let j = 0; j < cols; j++) {\r\n          currRow.push(createNode(i,j));\r\n    }\r\n    grid.push(currRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nfunction createNode(row, col) {\r\n  return {\r\n      row: row,\r\n      col: col,\r\n      isStart: (row === starting_location[0] && col === starting_location[1]), \r\n      isEnd: (row === ending_location[0] && col === ending_location[1]),\r\n      isWall: false,\r\n      isVisited: false,\r\n      isPath: false,\r\n      weight: DEFAULT_NODE_WEIGHT,\r\n      isWeight: false\r\n  };\r\n};\r\n\r\nfunction runAlgorithm(algoName, grid) {\r\n  let copyGrid = [...grid];\r\n  let paths;\r\n  switch(algoName) {\r\n    case \"DFS\":\r\n      paths = dfs(copyGrid, copyGrid[starting_location[0]][starting_location[1]], copyGrid[ending_location[0]][ending_location[1]]);\r\n      break;\r\n    case \"BFS\":\r\n      paths = bfs(copyGrid, copyGrid[starting_location[0]][starting_location[1]], copyGrid[ending_location[0]][ending_location[1]]);\r\n      break;\r\n    case \"Dijkstra\":\r\n      paths = dijkstra(copyGrid, copyGrid[starting_location[0]][starting_location[1]], copyGrid[ending_location[0]][ending_location[1]]);\r\n      break;\r\n    case \"A*\":\r\n      paths = astar(copyGrid, copyGrid[starting_location[0]][starting_location[1]], copyGrid[ending_location[0]][ending_location[1]]);\r\n      break;\r\n    case \"Bidirectional BFS\":\r\n      paths = bfs_bidirectional(copyGrid, copyGrid[starting_location[0]][starting_location[1]], copyGrid[ending_location[0]][ending_location[1]]);\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n  return paths;\r\n}\r\n\r\n\r\nexport default Grid;","export function dfs(grid, startNode, endNode) {\r\n    const visited = new Set();\r\n    let pathToNode = [startNode]; \r\n    const allNodesExplored = [];\r\n    const stack = [pathToNode];\r\n    const dI = [-1, 1, 0, 0] // 4 directions in array format\r\n    const dJ = [0, 0, -1, 1] // 4 directions in array format\r\n\r\n    while (stack.length > 0) {\r\n        pathToNode = stack.pop();\r\n        let root = pathToNode[pathToNode.length - 1];\r\n        if (!visited.has(root) && !root.isWall) {\r\n            visited.add(root) // mark as visited this node\r\n            allNodesExplored.push(root); // Add our root to our path\r\n            if (root === endNode) // Found our end spot\r\n                break;\r\n            for (let k = 0; k < 4; k++) {\r\n                if (root.row + dI[k] < 0 || root.row + dI[k] >= grid.length || \r\n                    root.col + dJ[k] < 0 || root.col + dJ[k] >= grid[0].length)\r\n                    continue;\r\n                const neighbor = grid[root.row + dI[k]][root.col + dJ[k]];\r\n                const pathToNeighbor = [...pathToNode, neighbor];\r\n                stack.push(pathToNeighbor);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        shortestPath: pathToNode,\r\n        fullPath: allNodesExplored\r\n    };\r\n}\r\n","export function bfs(grid, startNode, endNode) {\r\n    const visited = new Set();\r\n    let pathToNode = [startNode]; \r\n    const allNodesExplored = [];\r\n    const queue = [pathToNode];\r\n    const dI = [-1, 1, 0, 0] // 4 directions in array format\r\n    const dJ = [0, 0, -1, 1] // 4 directions in array format\r\n\r\n    while (queue.length > 0) {\r\n        pathToNode = queue.shift();\r\n        let root = pathToNode[pathToNode.length - 1];\r\n        if (!visited.has(root) && !root.isWall) {\r\n            visited.add(root) // mark as visited this node\r\n            allNodesExplored.push(root); // Add our root to our path\r\n            if (root === endNode) // Found our end spot\r\n                break;\r\n            for (let k = 0; k < 4; k++) {\r\n                if (root.row + dI[k] < 0 || root.row + dI[k] >= grid.length || \r\n                    root.col + dJ[k] < 0 || root.col + dJ[k] >= grid[0].length)\r\n                    continue;\r\n                const neighbor = grid[root.row + dI[k]][root.col + dJ[k]];\r\n                const pathToNeighbor = [...pathToNode, neighbor];\r\n                queue.push(pathToNeighbor);\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        shortestPath: pathToNode,\r\n        fullPath: allNodesExplored\r\n    };\r\n}\r\n","import React from \"react\";\r\nimport Grid from \"./Components/Grid\";\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport './App.scss';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Grid />\r\n    </div>\r\n  );\r\n}\r\n  \r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(<App />, document.getElementById(\"root\"));"],"sourceRoot":""}